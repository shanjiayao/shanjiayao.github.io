# 目标跟踪中的边界效应与余弦窗平滑


---

本文主要介绍学习目标跟踪算法时遇到的关于边界效应以及余弦窗平滑的相关知识

## 1. 边界效应

### 1.1 背景

在目标跟踪算法中，`边界效应`最早在的出现，是在基于相关滤波方法的目标跟踪算法中。

先简述相关滤波的目标跟踪算法，相关滤波(correlation filter)是一种模板类方法，采用在线模板匹配的方式，在线学习模板变化，但是相关滤波的缺点也很明显，对**快速变形和快速运动情况的跟踪效果不好**。

`快速变形`效果差是因为模板类方法的机制，快速形变的时候，对于目标模板的基于HOG的梯度计算很难跟上目标，目标快速变色也会导致模板无法准确适应的情况，此外，在线学习的模板更新策略与更新频率都会影响跟踪效果

而`快速运动`效果差则是因为所谓的边界效应，目标的快速运动会导致相邻两帧之间目标在图像中的像素距离过大，从到导致跟踪效果差甚至跟踪失败的现象

### 1.2 定义

对于边界效应的**定义**，如下：

***宏观上来看，目标在被跟踪过程中，在下一帧图像中的位置偏离了search window中心太远，比如非常靠近边缘、出去一半、全部出去，叫做边界效应***

边界效应的产生原因，经查阅资料，源于在跟踪算法中引入了离散傅里叶变换，这极大地提高了算法的计算效率，不过也产生了副作用，就是边界效应

### 1.3 总结

对于边界效应，其根本原因可以概括为三个字，`大位移`，其实实际应用中，这种情况都是经常遇到的，因为我们所说的位移是针对传感器坐标系下的，是相对量，并不一定是世界坐标系下，所以产生的原因可能有两点

- 处理频率低
  
  包括传感器的采样频率以及算法的运行频率，我统称他们为处理频率，如果处理频率上不去，那么每次在新的搜索区域中寻找目标时，就会发现目标的位移`大`

- 实际运动快
  
  另外一种原因就是在世界坐标系下，目标的确处于高速运动，相对于传感器来说，两帧之间位置变化较大

### 1.4 解决方案

通常来说有两种经典的解决方案，分别是余弦窗机制以及增加搜索区域面积

1. 增加搜索区域面积
   
   这个很好理解，大的搜索区域可以很有效的解决边界效应，因为边界的概念是相对于搜索区域大小来定义的，但是缺陷是搜索区域的扩大同样也引入了更多的背景信息，容易造成跟踪模板的漂移，导致模板跟着背景走，一去不回头～

2. 余弦窗机制
   
   这也是本文想着重记录的，余弦窗机制不仅仅是出现在基于相关滤波的目标算法中，基于深度学习孪生网络的目标跟踪器也有很多都用到了余弦窗来做平滑
   
   但是这种机制自身也有一定的弊端，用的时候需要做取舍

## 2. 余弦窗机制

### 2.1 作用原理

余弦窗机制为什么能处理边界效应？

在相关滤波算法中，余弦窗的机制作用在像素上：***对搜索区域的像素做更改，使搜索区域边界的像素值接近0，这样可以消除边界的不连续性***

而在基于深度学习的目标跟踪算法中，余弦窗的引入则是针对于特征学习到的`score map`，*对得到的得分根据余弦窗进行重新加权，越靠近中心，认为得分越准确*，这时余弦窗的作用其实说成对错误检测结果的抑制更合理一点，因为在 `score map`中，大位移还有一种情况就是目标检测错误，这样使用余弦窗机制可以很好的对其进行抑制和惩罚

### 2.2 缺点

在相关滤波中，余弦窗直接让边界像素趋近于0，这样会导致背景信息的弱化，甚至前景信息的丢失。背景信息的弱化是指像素趋近0让模板不能学习背景的特征，前景目标的丢失是说，当目标产生大位移，运动到边界时，余弦窗会让目标仅存的像素也被过滤掉，就导致无法跟踪快速运动的目标

在孪生网络中，在`score map`上使用余弦窗，个人感觉更多的是对分数的加权，这样做的目的是保证搜索区域中间的目标拥有最高的优先级，但是同样，这并不是一个可以适应所有情况的方案，比如说一个目标快速运动经过了另外一个相似目标，那么跟踪器可能就跟踪错误了

### 2.3 实现

深入了解余弦窗，我只找了其在深度学习中的应用，看的代码是[SiamMask](https://github.com/foolwood/SiamMask/blob/master/tools/test.py#L157)

```python
    # 定义
    if p.windowing == 'cosine':  # 默认cosine
        window = np.outer(np.hanning(p.score_size), np.hanning(p.score_size))   # 求外积 <(25, 25), float64>
    # 调用，更新score map中的分数
    pscore = pscore * (1 - p.window_influence) + window * p.window_influence  # ndarray<(3125,), float64>
```

调用的是`numpy`中的汉宁窗(`hanning`)和计算外积(`outer`)的函数

简单解释就是，使用汉宁窗初始化两个向量分别作为长和宽方向的定义，这里的余弦窗其实是正方形，所以两个向量大小一致，类似这样

```python
>>> np.hanning(12)
array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,
       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,
       0.07937323, 0.        ])
```

然后`np.outer`这个函数的作用就是计算两个向量的外积，结果是一个矩阵，大小等于向量大小的平方，类似这样

![外积结果](https://raw.githubusercontent.com/shmilywh/PicturesForBlog/master/2021/01/27-13-56-27-%E9%80%89%E5%8C%BA_584.png)

这样就得到了一个余弦窗，越靠近中心，其加权分数越大，将这个分数作用在得到的 `score map` 上，就可以起到对跟踪结果的惩罚和抑制作用了

## 参考

https://zhuanlan.zhihu.com/p/26417182

https://gsy00517.github.io/computer-vision20200120120823/

https://zhuanlan.zhihu.com/p/59624151

https://zhuanlan.zhihu.com/p/66757733

